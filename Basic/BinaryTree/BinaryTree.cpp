#include "BinaryTree.h"
#include <iostream>

BinaryTree::BinaryTree()
{
	_Root = nullptr;
}

BinaryTree::~BinaryTree()
{
	delete _Root;
}

bool BinaryTree::Insert(int Data)
{
	if (_Root == nullptr)
	{
		_Root = new Node;
		_Root->Data = Data;
		return true;
	}

	Node* node = _Root;
	while (1)
	{
		if (Data < node->Data)
		{
			if (node->Left == nullptr)
			{		
				Node* newNode = new Node;
				newNode->Data = Data;
				node->Left = newNode;
				break;
			}
			else
			{
				node = node->Left;
			}
		}
		else if (Data == node->Data)
		{
			return false;
		}
		else
		{
			if (node->Right == nullptr)
			{
				Node* newNode = new Node;
				newNode->Data = Data;
				node->Right = newNode;
				break;
			}
			else
			{
				node = node->Right;
			}
		}
	}

	return true;
}

bool BinaryTree::Delete(int Data)
{

	return false;
}

bool BinaryTree::Find(int Data)
{
	Search(_Root, Data);
}

void BinaryTree::Print()
{
	const int maxDepth = GetMaxDepth();

	// If this tree is empty, tell someone
	if (maxDepth == 0) {
		cout << " <empty tree>\n";
		return;
	}

	// This tree is not empty, so get a list of node values...
	const auto rowList = GetRowList(maxDepth);
	// then format these into a text representation...
	auto formattedRows = FormatRow(rowList);
	// then trim excess space characters from the left sides of the text...
	TrimRow(formattedRows);
	// then dump the text to cout.
	for (const auto& row : formattedRows) {
		std::cout << ' ' << row << '\n';
	}
}

int BinaryTree::GetMaxDepth() const
{
	
}

bool BinaryTree::Search(Node* node, int data)
{
	if (node == nullptr)
		return false;

	Search(node->Left, data);
	if (node->Data == data)
	{
		return true;
	}
	Search(node->Right, data);
}

RowList BinaryTree::GetRowList(int maxDepth) const
{
	RowList rowList;

	vector<Node*> traversalStack;
	vector<vector<Node*>> rows;
	if (_Root == nullptr) 
		return rowList;

	Node* p = _Root;
	rows.resize(maxDepth);
	int depth = 0;
	for (;;) {
		// Max-depth Nodes are always a leaf or null
		// This special case blocks deeper traversal
		if (depth == maxDepth - 1) {
			rows[depth].push_back(p);
			if (depth == 0) break;
			--depth;
			continue;
		}

		// First visit to node?  Go to left child.
		if (traversalStack.size() == depth) {
			rows[depth].push_back(p);
			traversalStack.push_back(p);
			if (p) p = p->Left;
			++depth;
			continue;
		}

		// Odd child count? Go to right child.
		if (rows[depth + 1].size() % 2) {
			p = traversalStack.back();
			if (p) p = p->Right;
			++depth;
			continue;
		}

		// Time to leave if we get here

		// Exit loop if this is the root
		if (depth == 0) break;

		traversalStack.pop_back();
		p = traversalStack.back();
		--depth;
	}

	// Use rows of Node pointers to populate rows of cell_display structs.
	for (const auto& row : rows) {
		rowList.emplace_back();
		for (Node* pn : row) {
			Cell cell;
			if (pn) {
				cell.Value = to_string(pn->Data);
				cell.Present = true;
				rowList.back().push_back(cell);
			}
			else {
				rowList.back().push_back(cell);
			}
		}
	}

	return rowList;
}

// row_formatter takes the vector of rows of cell_display structs 
// generated by get_row_display and formats it into a test representation
// as a vector of strings
vector<string> BinaryTree::FormatRow(const RowList& rowList) const
{
	using s_t = string::size_type;

	// First find the maximum value string length and put it in cell_width
	s_t cell_width = 0;
	for (const auto& row_disp : rowList) {
		for (const auto& cd : row_disp) {
			if (cd.Present && cd.Value.length() > cell_width) {
				cell_width = cd.Value.length();
			}
		}
	}

	// make sure the cell_width is an odd number
	if (cell_width % 2 == 0) ++cell_width;

	// allows leaf nodes to be connected when they are
	// all with size of a single character
	if (cell_width < 3) cell_width = 3;


	// formatted_rows will hold the results
	vector<string> formatted_rows;

	// some of these counting variables are related,
	// so its should be possible to eliminate some of them.
	s_t row_count = rowList.size();

	// this row's element count, a power of two
	s_t row_elem_count = 1i64 << (row_count - 1);

	// left_pad holds the number of space charactes at the beginning of the bottom row
	s_t left_pad = 0;

	// Work from the level of maximum depth, up to the root
	// ("formatted_rows" will need to be reversed when done) 
	for (s_t r = 0; r < row_count; ++r) {
		const auto& cd_row = rowList[row_count - r - 1]; // r reverse-indexes the row
		// "space" will be the number of rows of slashes needed to get
		// from this row to the next.  It is also used to determine other
		// text offsets.
		s_t space = (s_t(1) << r) * (cell_width + 1) / 2 - 1;
		// "row" holds the line of text currently being assembled
		string row;
		// iterate over each element in this row
		for (s_t c = 0; c < row_elem_count; ++c) {
			// add padding, more when this is not the leftmost element
			row += string(c ? left_pad * 2 + 1 : left_pad, ' ');
			if (cd_row[c].Present) {
				// This position corresponds to an existing Node
				const string& valstr = cd_row[c].Value;
				// Try to pad the left and right sides of the value string
				// with the same number of spaces.  If padding requires an
				// odd number of spaces, right-sided children get the longer
				// padding on the right side, while left-sided children
				// get it on the left side.
				s_t long_padding = cell_width - valstr.length();
				s_t short_padding = long_padding / 2;
				long_padding -= short_padding;
				row += string(c % 2 ? short_padding : long_padding, ' ');
				row += valstr;
				row += string(c % 2 ? long_padding : short_padding, ' ');
			}
			else {
				// This position is empty, Nodeless...
				row += string(cell_width, ' ');
			}
		}
		// A row of spaced-apart value strings is ready, add it to the result vector
		formatted_rows.push_back(row);

		// The root has been added, so this loop is finsished
		if (row_elem_count == 1) break;

		// Add rows of forward- and back- slash characters, spaced apart
		// to "connect" two rows' Node value strings.
		// The "space" variable counts the number of rows needed here.
		s_t left_space = space + 1;
		s_t right_space = space - 1;
		for (s_t sr = 0; sr < space; ++sr) {
			string row;
			for (s_t c = 0; c < row_elem_count; ++c) {
				if (c % 2 == 0) {
					row += string(c ? left_space * 2 + 1 : left_space, ' ');
					row += cd_row[c].Present ? '/' : ' ';
					row += string(right_space + 1, ' ');
				}
				else {
					row += string(right_space, ' ');
					row += cd_row[c].Present ? '\\' : ' ';
				}
			}
			formatted_rows.push_back(row);
			++left_space;
			--right_space;
		}
		left_pad += space + 1;
		row_elem_count /= 2;
	}

	// Reverse the result, placing the root node at the beginning (top)
	reverse(formatted_rows.begin(), formatted_rows.end());

	return formatted_rows;
}

// Trims an equal number of space characters from
// the beginning of each string in the vector.
// At least one string in the vector will end up beginning
// with no space characters.
void BinaryTree::TrimRow(vector<string>& rows) 
{
	if (!rows.size()) return;
	auto min_space = rows.front().length();
	for (const auto& row : rows) {
		auto i = row.find_first_not_of(' ');
		if (i == string::npos) i = row.length();
		if (i == 0) return;
		if (i < min_space) min_space = i;
	}
	for (auto& row : rows) {
		row.erase(0, min_space);
	}
}